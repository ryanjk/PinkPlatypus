using UnityEngine;

/**
* NoiseGenerator
* @author Thomas Fix
*
* pseudo-Perlin noise generator
* See: http://devmag.org.za/2009/04/25/perlin-noise/ for the pseudocode used
* 
* The algorithm used from the source above creates a 2D array of random floats
* in the range [0.0f, 1.0f], then uses this "base" array to create a smoother
* random array called an octave, finally combining a certain number of octaves
* (decided by the local private variable _octaves), weighting each octave with
* an amplitude determined by the _persistence local private variable.
*/
public class NoiseGenerator {
    /**
    * Creates a 2D array of floats using Perlin noise alg
    * @param width The width of the desired array
    * @param height The height of the desired array
    */
    public float[,] GenerateNoise(int width, int height) {
        return GenerateBlendedArray(GenerateRandomArray(width, height), _octaves);
    }

    /**
    * Creates a 2D array of random floats in the range [0.0f, 1.0f]
    * @param width The width of the desired array
    * @param height The height of the desired array
    */
    private float[,] GenerateRandomArray(int width, int height) {
        float[,] result = new float[width, height];

        // each cell in the array gets a random float
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                result[i, j] = Random.value;
            }
        }
        return result;
    }

    /**
    * Generates an octave given the base random array and the octave number
    * @param randomArray The base array of random floats
    * @param octaveNum The current octave number of this array
    */
    private float[,] GenerateOctave(float[,] randomArray, int octaveNum) {
        // getting width and length of desired array from input array
        // and creating the array to be returned
        int width = randomArray.GetLength(0);
        int height = randomArray.GetLength(1);
        float[,] result = new float[width, height];

        // the period (also called the wavelength) of the octave, 2^(octaveNum)
        // determines the "size" of the noise of the octave - higher the octave number,
        // bigger the noise
        // frequency is the inverse of period
        int period = 1 << octaveNum;
        float frequency = 1.0f / period;

        // creating the "smooth" noise
        for (int i = 0; i < width; i++) {
            // sample x values and a blend amount (between 0.0f and 1.0f)
            // calculated from period, frequency and the current i value
            int i0 = (i / period) * period;
            int i1 = (i0 + period) % width;
            float hBlend = (i - i0) * frequency;

            for (int j = 0; j < height; j++) {
                // sample y values and a blend amount (between 0.0f and 1.0f)
                // calculated from period, frequency and the current j value
                // same as for the horizontal sample values above
                int j0 = (j / period) * period;
                int j1 = (j0 + period) % height;
                float vBlend = (j - j0) * frequency;

                // linear interpolation between the top two sample points taken from the sample
                // x and y values calculated above
                float top = Mathf.Lerp(randomArray[i0, j1], randomArray[i1, j1], hBlend);

                // same with the bottom two
                float bottom = Mathf.Lerp(randomArray[i0, j0], randomArray[i1, j0], hBlend);

                // then assign the value at the current indices as the linear interpolation
                // of the previous two values
                result[i, j] = Mathf.Lerp(top, bottom, vBlend);
            }
        }
        return result;
    }

    /**
    * Combines and blends "octaves" number of octaves generated by GenerateOctave
    * @param randomArray The base array of random floats
    * @param octaves The number of octaves in our noise generator
    */
    private float[,] GenerateBlendedArray(float[,] randomArray, int octaves) {
        // get the width and length of the input array
        int width = randomArray.GetLength(0);
        int height = randomArray.GetLength(1);

        // this is the array of "smooth" noise arrays
        float[][,] smoothNoise = new float[octaves][,];

        // generate the required number of octaves
        for (int i = 0; i < octaves; i++) {
            smoothNoise[i] = GenerateOctave(randomArray, i);
        }

        // the result array to be returned
        float[,] result = new float[width, height];

        // the weight to give each octave, and an accumulator for the total amp.
        float amplitude = 1.0f;
        float totalAmplitude = 0.0f;
        
        // iterating backwards through the array of octaves
        // i.e. "larger" first
        for(int curOctave = octaves - 1; curOctave >= 0; curOctave--) {
            // persistence multiplied by the current value of the amplitude
            // and accumulate totalAmplitude
            amplitude *= _persistence;
            totalAmplitude += amplitude;

            // for each cell in the result array, add the corresponding cell in the
            // current octave, multiplied by the amplitude
            for (int i = 0; i < width; i++) {
                for (int j = 0; j < height; j++) {
                    result[i, j] += smoothNoise[curOctave][i, j] * amplitude;
                }
            }
        }

        // normalize each value
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                result[i, j] /= totalAmplitude;
            }
        }

        return result;
    }

    // These values should be played around with a bit to settle on something usable
    private int _octaves = 6;
    private float _persistence = 0.5f;
}
